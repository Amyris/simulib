name: CI - Run Unit Tests in Docker with Coverage

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image with Cache
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile # Assuming Dockerfile is at the root
          # Build the 'dev' target stage
          target: dev
          # Tag the image locally so subsequent steps can use it
          tags: my-test-image:latest
          # IMPORTANT: Load the image into the local Docker daemon
          load: true
          # Enable layer caching using GitHub Actions cache
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run tests with dFBA extra
        run: |
          # Runs coverage collection via 'uv run' using --with pytest-cov.
          # Uses --parallel-mode for coverage data.
          # Generates uniquely named JUnit report.
          docker run --rm \
            -v "$(pwd):/app" \
            -w /app \
            my-test-image:latest \
            uv run --with dfba --with pytest --with pytest-cov coverage run --parallel-mode -m pytest ./tests/extras --junitxml=test-report-dfba.xml

      - name: Run tests without dFBA extra
        run: |
          # Runs coverage collection via 'uv run' using --with pytest-cov.
          # Uses --parallel-mode for coverage data.
          # Generates uniquely named JUnit report.
          docker run --rm \
            -v "$(pwd):/app" \
            -w /app \
            my-test-image:latest \
            uv run --with pytest --with pytest-cov coverage run --parallel-mode -m pytest ./tests/core --junitxml=test-report-core.xml

      # --- The step below only runs if BOTH test steps above succeeded ---

      - name: Combine and Report Coverage
        if: success()
        run: |
          # Runs combine, report, and html generation in a single container
          # Saves the console summary to /app/coverage_summary.txt within the container
          # which maps to coverage_summary.txt on the runner host via the volume mount.
          docker run --rm \
            -v "$(pwd):/app" \
            -w /app \
            my-test-image:latest \
            sh -c '\
              echo "Combining coverage data..." && \
              uv run --with pytest --with pytest-cov coverage combine && \
              echo "Generating coverage summary..." && \
              uv run --with pytest --with pytest-cov coverage report -m > /app/coverage_summary.txt && \
              echo "Generating HTML coverage report..." && \
              uv run --with pytest --with pytest-cov coverage html -d htmlcov \
            '
          # Also echo the summary to the main job log for easy viewing there
          echo "--- Coverage Summary ---"
          cat coverage_summary.txt
          echo "------------------------"

      - name: Format Coverage Comment Body
        # Prepare the content for the comment in a file
        # Only run on successful PR builds
        if: success() && github.event_name == 'pull_request'
        run: |
          echo '### :test_tube: Coverage Report' > coverage_comment.md
          echo '' >> coverage_comment.md
          echo '```text' >> coverage_comment.md
          cat coverage_summary.txt >> coverage_comment.md
          echo '' >> coverage_comment.md # Ensure newline before closing fence
          echo '```' >> coverage_comment.md
          # Optional: Add a hidden HTML comment marker for extra safety/identification
          # echo "<!-- coverage-report-marker -->" >> coverage_comment.md
  
      - name: Post or Update Coverage Comment
          # Use the sticky comment action
          # Only run on successful PR builds
        if: success() && github.event_name == 'pull_request'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          # Tell the action to read the comment body from the file we just created
          path: coverage_comment.md

  # --- Automatic TestPyPI Publish Job ---
  publish-to-testpypi:
    name: Publish Dev Build to TestPyPI
    needs: test # Depends on test job succeeding
    # Runs ONLY on push events to the main branch (not PRs, not manual triggers)
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' && needs.test.result == 'success'
    runs-on: ubuntu-latest
    environment:
      name: testpypi
      url: https://test.pypi.org/p/simulib # <-- IMPORTANT: Replace simulib with your package name
    permissions:
      id-token: write # Needed for Trusted Publishing
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for versioning if using setuptools_scm later

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install uv
        run: curl -LsSf https://astral.sh/uv/install.sh | sh

      - name: Install build tools and tomlkit
        run: uv pip install --system --upgrade build tomlkit

      - name: Set Development Version
        id: set_dev_version
        # This script reads pyproject.toml, appends .dev<RUN_NUMBER> to the version,
        # and writes it back. Assumes standard `project.version`.
        # Adjust ['project']['version'] if your version is elsewhere (e.g., ['tool']['poetry']['version'])
        run: |
          import tomlkit, os, sys
          run_number = os.environ['GITHUB_RUN_NUMBER']
          toml_path = 'pyproject.toml'
          try:
            with open(toml_path, 'r') as f: data = tomlkit.parse(f.read())
            # *** ADJUST THIS LINE if your version is not at ['project']['version'] ***
            base_version = data['project']['version']
            base_version = base_version.split('.dev')[0].split('+')[0] # Clean existing dev/local parts
            dev_version = f"{base_version}.dev{run_number}"
            print(f"Setting version for TestPyPI: {dev_version}")
            # *** ADJUST THIS LINE if your version is not at ['project']['version'] ***
            data['project']['version'] = dev_version
            with open(toml_path, 'w') as f: f.write(tomlkit.dumps(data))
            # Set output for potential use in other steps (optional)
            echo "dev_version=${dev_version}" >> $GITHUB_OUTPUT
          except Exception as e:
            print(f"Error updating version in {toml_path}: {e}", file=sys.stderr)
            sys.exit(1)
        env:
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        shell: python # Use python directly to run the script block

      - name: Build package with dev version
        run: python -m build

      - name: Publish package to TestPyPI
        run: >
          uv publish --repository-url https://test.pypi.org/legacy/ dist/*

    # --- Manual PyPI Publish Job ---
  publish-to-pypi:
    name: Publish Release to PyPI (Manual Trigger)
    needs: test # Run tests again before publishing the release
    # Runs ONLY on manual workflow_dispatch trigger
    if: github.event_name == 'workflow_dispatch' && needs.test.result == 'success'
    runs-on: ubuntu-latest
    environment:
      name: pypi # MUST MATCH the environment name configured in PyPI Trusted Publishers
      url: https://pypi.org/p/simulib # <-- IMPORTANT: Replace simulib with your package name
    permissions:
      id-token: write # Needed for Trusted Publishing on PyPI
    steps:
      - name: Checkout code
        # Checkout code again for this job's environment
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install uv
        run: curl -LsSf https://astral.sh/uv/install.sh | sh

      - name: Install build dependency using uv
        run: uv pip install --system --upgrade build

      - name: Build package (using version from pyproject.toml)
        # This builds the package using the version defined in your checked-out pyproject.toml
        # Assumes this is the intended release version.
        run: python -m build

      - name: Publish package to PyPI using uv and Trusted Publishing
        run: uv publish dist/*
