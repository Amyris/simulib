name: CI - Run Unit Tests in Docker with Coverage

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image with Cache
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile # Assuming Dockerfile is at the root
          # Build the 'dev' target stage
          target: dev
          # Tag the image locally so subsequent steps can use it
          tags: my-test-image:latest
          # IMPORTANT: Load the image into the local Docker daemon
          load: true
          # Enable layer caching using GitHub Actions cache
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run tests with dFBA extra
        run: |
          # Runs coverage collection via 'uv run' using --with pytest-cov.
          # Uses --parallel-mode for coverage data.
          # Generates uniquely named JUnit report.
          docker run --rm \
            -v "$(pwd):/app" \
            -w /app \
            my-test-image:latest \
            uv run --with dfba --with pytest --with pytest-cov coverage run --parallel-mode -m pytest ./tests/extras --junitxml=test-report-dfba.xml

      - name: Run tests without dFBA extra
        run: |
          # Runs coverage collection via 'uv run' using --with pytest-cov.
          # Uses --parallel-mode for coverage data.
          # Generates uniquely named JUnit report.
          docker run --rm \
            -v "$(pwd):/app" \
            -w /app \
            my-test-image:latest \
            uv run --with pytest --with pytest-cov coverage run --parallel-mode -m pytest ./tests/core --junitxml=test-report-core.xml

      # --- The step below only runs if BOTH test steps above succeeded ---

      - name: Combine and Report Coverage
        if: success()
        run: |
          # Runs combine, report, and html generation in a single container
          # Saves the console summary to /app/coverage_summary.txt within the container
          # which maps to coverage_summary.txt on the runner host via the volume mount.
          docker run --rm \
            -v "$(pwd):/app" \
            -w /app \
            my-test-image:latest \
            sh -c '\
              echo "Combining coverage data..." && \
              uv run --with pytest --with pytest-cov coverage combine && \
              echo "Generating coverage summary..." && \
              uv run --with pytest --with pytest-cov coverage report -m > /app/coverage_summary.txt && \
              echo "Generating HTML coverage report..." && \
              uv run --with pytest --with pytest-cov coverage html -d htmlcov \
            '
          # Also echo the summary to the main job log for easy viewing there
          echo "--- Coverage Summary ---"
          cat coverage_summary.txt
          echo "------------------------"

      - name: Format Coverage Comment Body
        # Prepare the content for the comment in a file
        # Only run on successful PR builds
        if: success() && github.event_name == 'pull_request'
        run: |
          echo '### :test_tube: Coverage Report' > coverage_comment.md
          echo '' >> coverage_comment.md
          echo '```text' >> coverage_comment.md
          cat coverage_summary.txt >> coverage_comment.md
          echo '' >> coverage_comment.md # Ensure newline before closing fence
          echo '```' >> coverage_comment.md
          # Optional: Add a hidden HTML comment marker for extra safety/identification
          # echo "<!-- coverage-report-marker -->" >> coverage_comment.md
  
      - name: Post or Update Coverage Comment
          # Use the sticky comment action
          # Only run on successful PR builds
        if: success() && github.event_name == 'pull_request'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          # Tell the action to read the comment body from the file we just created
          path: coverage_comment.md

# --- New Job: Publish to TestPyPI (Manual Trigger) ---
  publish-testpypi:
    name: Publish to TestPyPI
    # This job only runs when manually triggered via workflow_dispatch
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment:
      name: testpypi # Environment name configured in GitHub secrets/settings
      url: https://test.pypi.org/pypi # URL shown in GH deployments
    permissions:
      id-token: write # Necessary for trusted publishing

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        # Fetch all history so build tools relying on tags/history work
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10' # Choose your desired Python version

      - name: Install build dependencies
        run: python -m pip install build twine

      - name: Generate development version suffix
        id: version_suffix
        # Using timestamp for uniqueness on manual triggers
        run: echo "suffix=$(date +'%Y%m%d%H%M%S')" >> $GITHUB_OUTPUT

      # IMPORTANT: Modify this step based on your project structure
      # Option 1: Using sed (example for pyproject.toml with 'version = "..."')
      - name: Update version in pyproject.toml for TestPyPI
        run: |
          # Add .dev<timestamp> suffix to the version line
          # This command is basic, adjust the regex if your version format differs
          sed -i "s/^\(version\s*=\s*\"\)\(.*\)\"/\1\2.dev${{ steps.version_suffix.outputs.suffix }}\"/" pyproject.toml
          echo "Updated pyproject.toml with version suffix:"
          grep "^version" pyproject.toml

      - name: Build package
        run: python -m build

      - name: Publish package distributions to TestPyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          # No password needed, uses trusted publishing via OIDC
          repository-url: https://test.pypi.org/legacy/ # URL for TestPyPI uploads
          # skip-existing: true # Optional: prevents failures if version exists

  # --- New Job: Publish to PyPI (Manual Trigger, depends on TestPyPI success) ---
  publish-pypi:
    name: Publish to PyPI
    # This job only runs when manually triggered via workflow_dispatch
    if: github.event_name == 'workflow_dispatch'
    needs: publish-testpypi # Ensures this runs only after successful TestPyPI publish
    runs-on: ubuntu-latest
    environment:
      name: pypi # Environment name configured in GitHub secrets/settings
      url: https://pypi.org/pypi # URL shown in GH deployments
    permissions:
      id-token: write # Necessary for trusted publishing

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history if your build depends on git tags

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10' # Use the same or appropriate Python version

      - name: Install build dependencies
        run: python -m pip install build twine

      - name: Build package
        run: python -m build
        # Builds the package *again* - this time it should use the
        # final, clean version committed to your main branch (e.g., "1.2.3")
        # Ensure your pyproject.toml or setup.py has the correct final version before triggering.

      - name: Publish package distributions to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        # No password or repository_url needed, defaults to PyPI and uses OIDC
